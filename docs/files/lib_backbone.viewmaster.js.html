<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>lib&#x2F;backbone.viewmaster.js - Backbone.ViewMaster</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.7.0&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.7.0&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="..&#x2F;assets/css/logo.png" title="Backbone.ViewMaster"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 1.0.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/Backbone.ViewMaster.html">Backbone.ViewMaster</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input checked type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: lib&#x2F;backbone.viewmaster.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x2F;*global Backbone:true,  _:true, define:true *&#x2F;
&#x2F;*jshint boss:true, browser:true *&#x2F;

(function(root, factory) {

  &#x2F;&#x2F; Expose into global Backbone namespace if Backbone is global
  if (typeof root.Backbone === &quot;object&quot; &amp;&amp; typeof root._ === &quot;function&quot;) {
    root.Backbone.ViewMaster = factory(Backbone, _);
  }

  &#x2F;&#x2F; If we have AMD try requiring Backbone and build with it
  if (typeof define === &quot;function&quot; &amp;&amp; define.amd) {
    define([&quot;backbone&quot;, &quot;underscore&quot;], function(Backbone, _) {
      return Backbone.ViewMaster || factory(Backbone, _);
    });
  }

}(this, function (Backbone, _) {

  function ensureArray(ob){
    return _.isArray(ob) ? ob : [ob];
  }

  &#x2F;**
   * Few tested opinions on how to handle deeply nested views in Backbone.js focusing on encapsulation and reusability.
   *
   * &lt;https:&#x2F;&#x2F;github.com&#x2F;epeli&#x2F;backbone.viewmaster&gt;
   *
   * ***NOTE**: Most important methods &#x60;setView&#x60;, &#x60;appendView&#x60;, &#x60;prependView&#x60;
   * and &#x60;removeView&#x60; are protected methods.*
   *
   * @class Backbone.ViewMaster
   * @extends Backbone.View
   * *&#x2F;
  return Backbone.View.extend({

    constructor: function(opts) {
      Backbone.View.prototype.constructor.apply(this, arguments);


      &#x2F;**
       * Boolean indicating whether this view has been rendered at least once.
       * Set by the &#x60;render&#x60; method and used by the parent view.
       *
       * @property rendered
       * @type Boolean
       **&#x2F;
      this.rendered = false;

      this._views = {};
      this._eventBindings = [];
      this._remove = [];
      this._parent = null;
      this._bubble = null;
    },



    &#x2F;**
     * Bind a callback function to a given Backbone event emitter for the
     * lifetime of the view.
     *
     * @method bindTo
     * @param {Object} emitter Any Backbone events object
     * @param {String} event
     * @param {Function&#x2F;String} callback Callback function or view method as string
     * @param {Object} [context] Callback context. Defaults to view instance
     * @return {Object} binding
     *
     **&#x2F;
    bindTo: function(emitter, event, callback, context) {
      var binding;
      context = context || this;
      if (typeof callback === &quot;string&quot;) {
        callback = this[callback];
      }
      if (!emitter || !event || !callback) {
        throw new Error(&quot;Bad arguments. The signature is &lt;emitter&gt;, &lt;event&gt;, &lt;callback &#x2F; callback name&gt;, [context]&quot;);
      }
      binding = {
        emitter: emitter,
        context: context,
        callback: callback,
        event: event
      };

      emitter.on(event, callback, context);
      this._eventBindings.push(binding);
      return binding;
    },


    &#x2F;**
     * Unbind all event callbacks this view has bound with &#x60;bindTo&#x60;. Internally
     * called by &#x60;remove&#x60;.
     *
     * @method unbindAll
     * @return {Object} this
     **&#x2F;
    unbindAll: function() {
      var binding;
      while(binding = this._eventBindings.shift()) this.unbindFrom(binding);
      return this;
    },


    &#x2F;**
     * Unbind single &#x60;binding&#x60; bound with &#x60;bindTo&#x60;.
     *
     * @method unbindFrom
     * @param {Object} binding
     **&#x2F;
    unbindFrom: function(binding) {
      binding.emitter.off(binding.event, binding.callback, binding.context || this);
      return this;
    },

    &#x2F;**
     * TODO: doc me
     *
     * @property elements
     **&#x2F;
    elements: {},


    &#x2F;**
     * Template function. User must override this!
     *
     * @method template
     * @param {Object} context
     * @return {String &#x2F; DOM object} rendered template
     **&#x2F;
    template: function(){
      throw new Error(&quot;Template function not defined!&quot;);
    },

    &#x2F;**
     * Returns the context object for the &#x60;template&#x60; method.
     *
     * Default: this.model.toJSON() or an empty object if view has no model.
     *
     * @method context
     * @return {Object} context
     **&#x2F;
    context: function() {
      if (this.model) return this.model.toJSON();
      return {};
    },


    &#x2F;**
     * Render view with &#x60;this.template(this.context())&#x60; and call
     * &#x60;this.renderViews(options)&#x60; to render childViews.
     *
     * @method render
     * @param {Object} options
     *   @param {Boolean} [options.force]
     *   force rerendering of child views
     * @return {Object} this
     **&#x2F;
    render: function(opts) {
      opts = _.extend({}, opts);

      &#x2F;&#x2F; Remove subviews with detach. This way they don&#x27;t lose event handlers
      this._detachViews();
      opts.detach = false;

      this.$el.html(this.template(this.context()));
      var key, selector;
      for (key in this.elements) {
        selector = this.elements[key];
        this[key] = this.$(selector);
      }

      &#x2F;&#x2F; Mark this view as rendered. Parent view wont try to render this
      &#x2F;&#x2F; anymore unless force:true is passed
      this.rendered = true;

      this.renderViews(opts);

      return this;
    },


    &#x2F;**
     *
     * Render child views only.
     *
     * @method renderViews
     * @param {Object} options
     *   @param {Boolean} [options.force]
     *   force rerendering of child views
     * @return {Object} this
     **&#x2F;
    renderViews: function(opts) {
      var self = this;
      opts = _.extend({ detach: true }, opts);

      var oldView;
      while (oldView = this._remove.shift()) oldView.remove();
      if (opts.detach) this._detachViews();

      this.eachView(function(containerSel, view) {
        if (opts.force || !view.rendered) view.render(opts);
        self.$(containerSel).append(view.el);
      });

      return this;
    },

    &#x2F;**
     * Detach view from its parent.
     *
     * @method detachParent
     * @return {Object} this
     **&#x2F;
    detachParent: function() {

      if (!this._parent) return;

      var key;
      for (key in this._parent._views) {
        this._parent._views[key] = _.without(
          this._parent._views[key], this
        );
      }

      this.unbindFrom(this._bubble);
      this._bubble = null;
      this._parent = null;

      return this;
    },


    _prepareViews: function(views) {
      var self = this;
      ensureArray(views).forEach(function(view) {

        &#x2F;&#x2F; when parent is changing remove it from previous
        if (view._parent &amp;&amp; view._parent !== self) {
          view.detachParent();
        }

        if (!view._bubble) {
          view._bubble = view.bindTo(view, &quot;all&quot;, function(eventName, arg) {
            self.trigger(eventName, view, arg);
          }, view);
        }

        view._parent = self;
      });
    },

    &#x2F;**
     * Iterate each child view.
     *
     * @method eachView
     * @param {Function} iterator
     *   @param {String} iterator.selector CSS selector for the view container
     *   @param {Object} iterator.view The view object
     * @return {Object} this
     **&#x2F;
    eachView: function(fn) {
      var self = this;
      _.keys(this._views).forEach(function(containerSel) {
        var views = self._views[containerSel];
        if (!views) return;
        views.forEach(function(view) {
          fn(containerSel, view);
        });
      });
    },

    _detachViews: function() {
      this.eachView(function(containerSel, view) {
        view.$el.detach();
      });
    },

    &#x2F;**
     * Set a view or an array of views to a given view container.
     *
     * @method setView
     * @protected
     * @param {String} selector CSS selector for the view container
     * @param {Object&#x2F;Array} view(s) View object or an array of view objects
     **&#x2F;
    setViews: function(containerSel, currentViews) {
      var previousViews;
      currentViews = ensureArray(currentViews);

      if (previousViews = this._views[containerSel]) {
        this._remove = this._remove.concat(
            _.difference(previousViews, currentViews)
        );
      }

      this._prepareViews(currentViews);
      this._views[containerSel] = currentViews;
      return this;
    },

    getViews: function(containerSel) {
      return this._views[containerSel];
    },

    &#x2F;**
     * Append a view or an array of views to a given view container.
     *
     * @method appendView
     * @protected
     * @param {String} selector CSS selector for the view container
     * @param {Object&#x2F;Array} view(s) View object or an array of view objects
     **&#x2F;
    appendViews: function(containerSel, views) {
      this._prepareViews(views);
      this._views[containerSel] = (this._views[containerSel] || []).concat(
        ensureArray(views)
      );
      return this;
    },

    &#x2F;**
     * Prepend a view or an array of views to a given view container.
     *
     * @method prependView
     * @protected
     * @param {String} selector CSS selector for the view container
     * @param {Object&#x2F;Array} view(s) View object or an array of view objects
     **&#x2F;
    prependViews: function(containerSel, views) {
      this._prepareViews(views);
      this._views[containerSel] = ensureArray(views).concat(
        this._views[containerSel] || []
      );
      return this;
    },

    &#x2F;**
     * Remove a view or an array of views from this view.
     *
     * @method removeView
     * @protected
     * @param {String} selector CSS selector for the view container
     * @param {Object&#x2F;Array} view(s) View or array of views
     * @return {Object} this
     **&#x2F;
    removeViews: function(containerSel, toBeRemoved){
      if (!this._views[containerSel]) return this;
      toBeRemoved = ensureArray(toBeRemoved);

      this._views[containerSel] = _.difference(
        this._views[containerSel],
        toBeRemoved
      );

      this._remove = this._remove.concat(toBeRemoved);
      return this;
    },

    remove: function() {
      Backbone.View.prototype.remove.apply(this, arguments);
      this.unbindAll();
      this.detachParent();
      this.eachView(function(containerSel, view) {
        view.remove();
      });
      return this;
    }

  });

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
